# 2 ПРОЄКТУВАННЯ ІНФОРМАЦІЙНОЇ СИСТЕМИ

## 2.1 Обґрунтування вибору архітектури

Для розв'язання поставлених задач автоматизації управління міським транспортом було обрано **трирівневу архітектуру** (Three-Tier Architecture) [1]. Вибір даної архітектури для проєкту міського транспорту зумовлений тим, що система обслуговує транспортну мережу міста з різними категоріями користувачів (пасажири, водії, диспетчери, контролери, бухгалтери тощо), тому необхідно мати єдине сховище даних, до якого звертаються всі ролі. Відокремлення рівнів дозволяє масштабувати систему при додаванні нових маршрутів, транспортних засобів та користувачів без зміни логіки інших рівнів.

Трирівнева архітектура дозволяє реалізувати механізм динамічної безпеки, де сервер додатків виступає надійним посередником, що керує правами доступу на рівні БД залежно від ролі користувача [2]. Оскільки транспортна система передбачає фінансові операції (продаж квитків, поповнення транспортних карток, облік штрафів) та критичні операції диспетчеризації (призначення водіїв, управління рейсами), де неприпустимі помилки, доцільним рішенням є винесення частини бізнес-логіки на рівень даних у вигляді збережених функцій PostgreSQL, що забезпечує цілісність даних незалежно від роботи клієнтського ПЗ [3].

Архітектура системи складається з наступних рівнів:

- **рівень представлення** — клієнтська частина, реалізована у вигляді односторінкового веб-застосунку (SPA) на основі бібліотеки React 19 [4] з використанням збірника Vite 7 [5], який відображається у браузері користувача. Для маршрутизації застосовано TanStack Router [6], для управління серверним станом — TanStack Query [7], для візуалізації маршрутів та зупинок — бібліотеку MapLibre GL [8]. Взаємодія з сервером відбувається через протокол HTTP/HTTPS за допомогою бібліотеки Axios [9];

- **рівень бізнес-логіки** — серверна частина, розроблена мовою TypeScript [10] з використанням фреймворку NestJS 11 [11]. Цей рівень відповідає за обробку HTTP-запитів, маршрутизацію, валідацію вхідних даних, автентифікацію користувачів та управління сесіями. Особливістю даного рівня у розробленій системі є динамічне підключення до бази даних під конкретним користувачем: кожен автентифікований користувач працює з PostgreSQL під власною роллю, що забезпечує розмежування доступу на рівні СУБД. Сесії користувачів зберігаються у Redis [12] з налаштованим часом життя;

- **рівень даних** — сервер бази даних PostgreSQL 16 [3] з розширеннями PostGIS [13] для геопросторових операцій (пошук найближчих зупинок, розрахунок відстаней) та pgRouting [14] для побудови оптимальних маршрутів. На цьому рівні реалізовано зберігання інформації, рольову модель доступу (ролі `ct_guest_role`, `ct_passenger_role`, `ct_driver_role`, `ct_dispatcher_role`, `ct_controller_role`, `ct_manager_role`, `ct_municipality_role`, `ct_accountant_role`), а також частину бізнес-логіки у вигляді SECURITY DEFINER функцій, що забезпечує додатковий рівень безпеки та цілісності даних.

Взаємодія компонентів відбувається наступним чином: користувач взаємодіє з веб-інтерфейсом (React), клієнт надсилає HTTP-запит до NestJS API із JWT-токеном у заголовку Authorization, контролер отримує запит та передає його сервісу, який реалізує бізнес-логіку і звертається до БД через Drizzle ORM [15]. Права доступу визначаються рольовою моделлю PostgreSQL та контекстом сесії, що зберігається в Redis. Результат повертається контролеру й далі клієнту у вигляді JSON-відповіді, після чого інтерфейс оновлюється.

**[ВСТАВИТИ ДІАГРАМУ: схема трирівневої архітектури з наступними компонентами:**
- **Рівень представлення:** React 19 + Vite 7 + TanStack Router + MapLibre GL (браузер користувача)
- **Рівень бізнес-логіки:** NestJS 11 + Redis (сервер додатків)
- **Рівень даних:** PostgreSQL 16 + PostGIS + pgRouting (сервер БД)
- **Стрілки:** HTTP/HTTPS між клієнтом і сервером, TCP/IP між сервером і БД]

Рисунок 2.1 – Схема трирівневої архітектури системи «Міський транспорт»

Фактичні файли реалізації рівнів:
- рівень представлення: `frontend/src/main.tsx`, `frontend/src/routes/__root.tsx`, `frontend/src/lib/api.ts`;
- рівень бізнес-логіки: `backend/src/app.module.ts`, `backend/src/main.ts`, `backend/src/modules/auth/auth.controller.ts`, `backend/src/common/session/session.service.ts`;
- рівень даних: `backend/src/db/db.service.ts`, `backend/src/db/schema/`, `db/bootstrap.sql`.

Порівняння обраної архітектури з альтернативою наведено в таблиці 2.1.

Таблиця 2.1 – Порівняння архітектурних підходів

| Критерій | Дворівнева архітектура | Трирівнева архітектура (обрана) |
|----------|------------------------|--------------------------------|
| Розділення відповідальностей | Часткове | Повне (UI, логіка, дані) |
| Масштабованість | Обмежена | Висока (незалежне масштабування рівнів) |
| Безпека | Клієнт має прямий доступ до БД | Сервер додатків як захисний бар'єр |
| Гнучкість | Низька | Висока (можливість підключення різних клієнтів) |
| Підтримка багатьох ролей | Складна | Природна (рольова модель на кожному рівні) |
| Складність розробки | Низька | Середня |

## 2.2 Обґрунтування вибору шаблону проєктування

В якості шаблону проєктування програмного додатку обрано **MVC** (Model-View-Controller — Модель-Представлення-Контролер), реалізований на базі фреймворку NestJS [11]. Використання даного патерну є обґрунтованим тим, що специфіка транспортної системи вимагає різного представлення для ролей: графік рейсів для водія, панель моніторингу для диспетчера, фінансові звіти для бухгалтера та карта маршрутів для пасажира. MVC дозволяє легко змінювати представлення для кожної ролі, не зачіпаючи логіку обробки даних.

Також, оскільки завдання на кшталт розрахунку відстаней через PostGIS, генерації розкладу відправлень або атомарної купівлі квитка з перевіркою балансу є складними, патерн MVC дозволяє інкапсулювати ці операції в моделі, залишаючи контролер легким і відповідальним лише за маршрутизацію та валідацію.

Патерн MVC дозволяє розділити логіку обробки даних, інтерфейс користувача та керування потоком виконання:

- **Модель (Model)** — представляє структуру даних та правила їх обробки. У даному проєкті модель реалізована на двох рівнях: Drizzle ORM схеми (`backend/src/db/schema/*.ts`) для типобезпечної роботи з таблицями та SQL-функції PostgreSQL (`*_api` схеми) для критичних бізнес-операцій. Модель надає дані Контролеру та реагує на команди шляхом зміни свого стану;

- **Представлення (View)** — відповідає за відображення даних користувачеві та отримання від користувача команд для роботи з даними. Реалізовано на React 19 з використанням компонентної архітектури. Основні компоненти розташовані в `frontend/src/routes/` (сторінки для кожної ролі) та `frontend/src/components/` (перевикористовувані UI-компоненти). Для стилізації застосовано Tailwind CSS [16] та бібліотеку компонентів shadcn/ui [17];

- **Контролер (Controller)** — забезпечує зв'язок між користувачем та системою, відповідає за перетворення команд користувача в набір дій над Моделлю. У NestJS контролери організовані за модульним принципом:
  - ресурсні контролери (`backend/src/modules/{entity}/{entity}.controller.ts`) — CRUD-операції для сутностей;
  - рольові контролери (`backend/src/roles/{ct-role}/{ct-role}.controller.ts`) — специфічні ендпоінти для кожної ролі (CtGuestController, CtPassengerController, CtDriverController, CtDispatcherController, CtControllerController, CtManagerController, CtMunicipalityController, CtAccountantController).

Схему взаємодії між компонентами MVC у розробленій системі наведено на рисунку 2.2.

**[ВСТАВИТИ ДІАГРАМУ: схема MVC з наступними компонентами:**
- **View (React):** Компоненти UI → Відправка HTTP-запитів → Відображення відповіді
- **Controller (NestJS):** Отримання запиту → Валідація → Виклик Service → Формування відповіді
- **Model (PostgreSQL + Drizzle):** Drizzle схеми → SQL-функції → Таблиці БД
- **Стрілки:** View ↔ Controller ↔ Model з підписами дій]

Рисунок 2.2 – Схема взаємодії компонентів MVC у системі «Міський транспорт»

Чому MVC є доречним для даної системи:

1. **Багаторольовість.** Система має 8 типів користувачів з різними сценаріями відображення, тому важливо мати незалежність View від логіки обробки даних. Кожна роль має власний набір сторінок у View та власний контролер.

2. **Складність бізнес-логіки.** Операції на кшталт розрахунку пасажиропотоку, нарахування зарплати водіям або аналітики доходів та витрат є складними. Патерн MVC дозволяє інкапсулювати ці розрахунки в моделі (Service + PostgreSQL функції), залишаючи контролер легким.

3. **Тестованість.** MVC дозволяє тестувати кожен компонент незалежно: контролери та сервіси перевіряються unit-тестами, компоненти React — component-тестами, SQL-функції — інтеграційними тестами.

4. **Розширюваність.** Додавання нових функцій для ролі не впливає на інші частини системи: достатньо додати новий метод у Controller та Service.

Приклад реалізації MVC для функції «Перегляд розкладу водієм»:

**View (React Component):**
```typescript
// frontend/src/routes/driver.tsx
function DriverSchedulePage() {
  const { data: schedule, isLoading } = useQuery({
    queryKey: ['driver-schedule'],
    queryFn: () => apiGet('/driver/schedule'),
  });

  if (isLoading) return <Skeleton />;

  return (
    <Card>
      <CardHeader>
        <CardTitle>Мій розклад на сьогодні</CardTitle>
      </CardHeader>
      <CardContent>
        <ScheduleTable trips={schedule.trips} />
      </CardContent>
    </Card>
  );
}
```

**Controller (NestJS):**
```typescript
// backend/src/roles/ct-driver/ct-driver.controller.ts
@Controller('driver')
export class CtDriverController {
  constructor(private readonly ctDriverService: CtDriverService) {}

  @Get('schedule')
  getSchedule(@Query('date') date?: string) {
    return this.ctDriverService.getSchedule(date);
  }
}
```

**Model (Service + PostgreSQL):**
```typescript
// backend/src/roles/ct-driver/ct-driver.service.ts
@Injectable()
export class CtDriverService {
  constructor(private readonly dbService: DbService) {}

  async getSchedule(date?: string) {
    const result = await this.dbService.db.execute(sql`
      SELECT * FROM driver_api.v_my_schedule
      WHERE schedule_date = COALESCE(${date}::date, CURRENT_DATE)
    `);
    return transformToCamelCase(result.rows);
  }
}
```

```sql
-- PostgreSQL View (Model)
CREATE VIEW driver_api.v_my_schedule AS
SELECT t.id, t.planned_starts_at, t.status,
       r.number AS route_number, r.direction
FROM trips t
JOIN routes r ON r.id = t.route_id
JOIN drivers d ON d.id = t.driver_id
WHERE d.login = current_user  -- Фільтрація за поточним користувачем
  AND t.planned_starts_at::date = CURRENT_DATE;
```

Порівняння патернів MVC та MVP наведено в таблиці 2.2.

Таблиця 2.2 – Порівняння патернів проєктування

| Критерій | MVC (обраний) | MVP |
|----------|---------------|-----|
| Зв'язок View-Model | Через Controller | Тільки через Presenter |
| Роль Controller/Presenter | Обробка команд, вибір View | Повний посередник |
| Підтримка у фреймворках | NestJS, Spring, ASP.NET | Менш поширена |
| Складність реалізації | Низька | Середня |
| Тестування | Просте | Просте |

Таким чином, застосування патерну MVC у поєднанні з трирівневою архітектурою забезпечує:
- **модульність** — кожен компонент має чітку відповідальність;
- **масштабованість** — можливість додавання нових ролей та функцій;
- **безпеку** — розмежування доступу на рівні контролерів та БД;
- **тестованість** — незалежне тестування кожного компонента.
