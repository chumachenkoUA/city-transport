**МІНІСТЕРСТВО ОСВІТИ І НАУКИ УКРАЇНИ**

**ДЕРЖАВНИЙ УНІВЕРСИТЕТ ІНТЕЛЕКТУАЛЬНИХ ТЕХНОЛОГІЙ ТА ЗВ'ЯЗКУ**

Факультет інтелектуальних технологій та кібербезпеки

Кафедра інженерії програмного забезпечення

**КУРСОВИЙ ПРОЕКТ**

з дисципліни
**«Бази даних»**

на тему:

СТВОРЕННЯ ІНФОРМАЦІЙНОЇ СИСТЕМИ

«МІСЬКИЙ ТРАНСПОРТ»

студента ІІI курсу

групи _____

спеціальності ІПЗ

_________________________________

(Прізвище, ім'я та по батькові)

Керівник: проф. Малахов Є.В.

(Прізвище, ім'я та по батькові)

Захищено «	» 	2025р.

з оцінкою

комісія:



(ПIБ)	(Підпис)



(ПIБ)	(Підпис)



(ПIБ)	(Підпис)

Одеса – 2025

# **АНОТАЦІЯ**

Курсовий проєкт присвячений розробці інформаційної системи «Міський транспорт» для автоматизації процесів управління міським громадським транспортом. Метою проєкту є створення програмного засобу, який забезпечує ефективне планування маршрутів, складання розкладів руху, продаж електронних квитків, моніторинг оплат, контроль штрафів та управління бюджетом транспортного підприємства.

У роботі виконано аналіз предметної області, обґрунтовано вибір засобів розробки та спроєктовано базу даних. Реалізація інформаційної системи виконана з використанням СУБД PostgreSQL 16 з розширеннями PostGIS та pgRouting для геопросторових операцій, мови програмування TypeScript з фреймворком NestJS для створення серверної частини та бібліотеки React для побудови інтерфейсу користувача. Архітектура системи побудована за принципом трирівневої клієнт-серверної архітектури з використанням патерну MVC.

Структура бази даних охоплює ключові сутності предметної області — маршрути, зупинки, транспортні засоби, водіїв, розклади, рейси, транспортні картки, квитки, штрафи та фінансові операції. Відмінною рисою системи є застосування концепції «товстої бази даних», де бізнес-логіка реалізована через збережені процедури та функції PL/pgSQL, а розмежування доступу здійснюється на рівні ролей PostgreSQL.

У системі реалізовано механізм JWT-автентифікації з підтримкою 8 типів користувачів: гість, пасажир, водій, диспетчер, контролер, менеджер, бухгалтер та департамент мерії. Кожна роль має власну схему API з представленнями та SECURITY DEFINER функціями для виконання дозволених операцій. Інтерфейс користувача розроблений з використанням MapLibre GL для візуалізації маршрутів на інтерактивній карті.

Розроблена система дозволяє централізувати управління транспортною мережею, автоматизувати продаж квитків та облік пасажиропотоку, забезпечити контроль штрафів з можливістю оскарження, формувати фінансову звітність та надавати пасажирам актуальну інформацію про рух транспорту в реальному часі.

# **ЗМІСТ**

[ВСТУП](#вступ)

[1 ПОСТАНОВКА ЗАВДАННЯ](#постановка-завдання)

[2 ПРОЄКТУВАННЯ ІНФОРМАЦІЙНОЇ СИСТЕМИ](#проєктування-інформаційної-системи)

[2.1 Обґрунтування вибору архітектури](#обґрунтування-вибору-архітектури)

[2.2 Обґрунтування вибору шаблону проєктування](#обґрунтування-вибору-шаблону-проєктування)

[3 ІНФОРМАЦІЙНЕ МОДЕЛЮВАННЯ ПРЕДМЕТНОЇ ОБЛАСТІ](#інформаційне-моделювання-предметної-області)

[4 ПРОГРАМНА МОДЕЛЬ ЗАСТОСУНКУ](#програмна-модель-застосунку)

[5 ВИБІР ПРОГРАМНОГО ЗАБЕЗПЕЧЕННЯ](#вибір-програмного-забезпечення)

[6 СТВОРЕННЯ БАЗИ ДАНИХ](#створення-бази-даних)

[6.1 Приклад створення таблиці](#приклад-створення-таблиці)

[6.2 Приклад створення таблиці із зовнішніми ключами](#приклад-створення-таблиці-із-зовнішніми-ключами)

[6.3 Приклад реалізації зв'язку «багато-до-багатьох»](#приклад-реалізації-звязку-багато-до-багатьох)

[6.4 Створення ролей та схем API](#створення-ролей-та-схем-api)

[7 ЗАПИТИ ДО БАЗИ ДАНИХ ДЛЯ РОЗВ'ЯЗАННЯ ПОСТАВЛЕНИХ ЗАДАЧ](#запити-до-бази-даних-для-розвязання-поставлених-задач)

[7.1 Розв'язання задач гостя](#розвязання-задач-гостя)

[7.2 Розв'язання задач пасажира](#розвязання-задач-пасажира)

[7.3 Розв'язання задач водія](#розвязання-задач-водія)

[7.4 Розв'язання задач диспетчера](#розвязання-задач-диспетчера)

[7.5 Розв'язання задач контролера](#розвязання-задач-контролера)

[7.6 Розв'язання задач менеджера](#розвязання-задач-менеджера)

[7.7 Розв'язання задач департаменту мерії](#розвязання-задач-департаменту-мерії)

[7.8 Розв'язання задач бухгалтера](#розвязання-задач-бухгалтера)

[8 ПРОГРАМНА РЕАЛІЗАЦІЯ ІНТЕРФЕЙСУ](#програмна-реалізація-інтерфейсу)

[8.1 Реалізація бекенд-додатку](#реалізація-бекенд-додатку)

[8.2 Реалізація фронтенд-додатку](#реалізація-фронтенд-додатку)

[9 БЕЗПЕКА ІНФОРМАЦІЙНОЇ СИСТЕМИ](#безпека-інформаційної-системи)

[10 ІНСТРУКЦІЯ КОРИСТУВАЧА](#інструкція-користувача)

[10.1 Загальні сторінки](#загальні-сторінки)

[10.2 Сторінки пасажира](#сторінки-пасажира)

[10.3 Сторінки водія](#сторінки-водія)

[10.4 Сторінки диспетчера](#сторінки-диспетчера)

[10.5 Сторінки контролера](#сторінки-контролера)

[10.6 Сторінки менеджера](#сторінки-менеджера)

[10.7 Сторінки бухгалтера](#сторінки-бухгалтера)

[10.8 Сторінки департаменту мерії](#сторінки-департаменту-мерії)

[ВИСНОВКИ](#висновки)

[СПИСОК ВИКОРИСТАНИХ ДЖЕРЕЛ](#список-використаних-джерел)

[ДОДАТОК А СХЕМА БАЗИ ДАНИХ](#додаток-а-схема-бази-даних)

[ДОДАТОК Б SQL-ЗАПИТИ ДЛЯ СТВОРЕННЯ ТАБЛИЦЬ, РОЛЕЙ ТА РОЗПОДІЛУ ДОСТУПУ](#додаток-б-sql-запити)

[ДОДАТОК В ЗАПИТИ НА СТВОРЕННЯ ФУНКЦІЙ ТА ПРЕДСТАВЛЕНЬ](#додаток-в-запити-на-створення-функцій)

[ДОДАТОК Г ВИХІДНИЙ КОД ОСНОВНИХ КЛАСІВ](#додаток-г-вихідний-код)

[ДОДАТОК Д ІЄРАРХІЯ СТОРІНОК ДОДАТКУ](#додаток-д-ієрархія-сторінок)

# **ВСТУП** {#вступ}

Сучасний міський транспорт є важливою складовою інфраструктури будь-якого великого міста. Ефективне управління транспортною мережею, що охоплює автобуси, тролейбуси та трамваї, потребує впровадження сучасних інформаційних технологій для координації маршрутів, розкладів, оплати проїзду та контролю якості обслуговування пасажирів.

Діяльність транспортного підприємства пов'язана з обробкою значних обсягів різнорідної інформації: даних про маршрути та зупинки, графіків руху транспорту, інформації про водіїв та транспортні засоби, фінансових транзакцій від продажу квитків та поповнення транспортних карток, а також обліку штрафів за безквитковий проїзд. Використання розрізнених програмних засобів або застарілих методів управління призводить до дублювання інформації, затримок в оновленні розкладів, складнощів у формуванні звітності та неможливості надати пасажирам актуальну інформацію про рух транспорту.

Актуальність теми курсового проєкту зумовлена необхідністю впровадження комплексної автоматизованої системи управління міським транспортом, яка дозволить централізувати управління всіма аспектами діяльності транспортного підприємства, забезпечити надійне зберігання даних, розмежувати права доступу для різних категорій користувачів та надати інструменти для оперативного моніторингу та аналітики.

Метою курсового проєкту є проєктування та розробка інформаційної системи для автоматизації бізнес-процесів управління міським громадським транспортом.

Для досягнення поставленої мети необхідно розв'язати такі завдання:

- провести системний аналіз предметної області, визначити основні бізнес-процеси та ролі користувачів системи;
- побудувати інфологічну та даталогічну моделі бази даних;
- реалізувати фізичну структуру бази даних у середовищі СУБД PostgreSQL з використанням розширень PostGIS та pgRouting;
- розробити серверну бізнес-логіку з використанням збережених процедур, функцій та представлень для забезпечення цілісності та автоматизації обробки даних;
- налаштувати підсистему безпеки на рівні бази даних із використанням рольової моделі доступу та схем API;
- розробити клієнтське програмне забезпечення з використанням NestJS для серверної частини та React для інтерфейсу користувача.

# 1 **ПОСТАНОВКА ЗАВДАННЯ** {#постановка-завдання}

В інформаційній системі передбачено вісім типів користувачів: пасажир (незареєстрований), пасажир (зареєстрований), водій, диспетчер, контролер, бухгалтер, департамент мерії та менеджер. У табл. 1.1 наведено перелік задач для кожного з користувачів із зазначенням вхідної та вихідної інформації.

Таблиця 1.1 – Задачі користувачів

| Задачі | Вхідна інформація | Вихідна інформація |
| ----- | ----- | ----- |
| **Пасажир (незареєстрований)** | | |
| 1. Перегляд зупинок | GPS дані користувача (довжина та широта) | Список найближчих зупинок: ID зупинок, їх координати, назва зупинок |
| 2. Перегляд руху транспорту, що проходить через зупинку | ID Зупинки | Список транспорту та маршрутів: номер маршруту, тип транспорту, приблизний час прибуття (хв) |
| 3. Перегляд маршруту | | |
| 3.1 Перегляд зупинок маршруту | Тип транспорту, номер маршруту | Список зупинок: ID зупинки, назва зупинки, координати зупинки |
| 3.2 Перегляд маршруту (для відображення на карті) | Тип транспорту, номер маршруту | Список точок між зупинками: координати кожної точки на маршруті |
| 4. Поїздка з точки А в точку Б | | |
| 4.1 Перегляд найближчих маршрутів з точки А в точку Б | Координати точки А, координати точки Б | Список (Тип транспорту, номер маршруту, час поїздки) |
| 4.2 Перегляд обраного маршруту | Координати початкової зупинки, координати кінцевої зупинки | Список точок між зупинками: координати кожної точки на маршруті |
| 5. Перегляд розкладу руху по обраному маршруту | Тип транспорту, номер маршруту, назва зупинки | Список (час відправлення, інтервал, час закінчення маршруту) |
| 6. Подача скарги чи пропозиції | Скарга/пропозиція, текст, дата, номер маршруту, тип транспорту, номер транспорту | |

Продовження таблиці 1.1

| Задачі | Вхідна інформація | Вихідна інформація |
| ----- | ----- | ----- |
| **Пасажир (зареєстрований)** | | |
| 1-6. Аналогічно незареєстрованому пасажиру | | |
| 7. Перегляд транспортної картки | ID користувача | Транспортна картка (ID картки, баланс) |
| 8. Поповнення транспортної картки | | |
| 8.1 Оплата | ID транспортної картки, сума | |
| 8.2 Перевірка балансу | ID транспортної картки | Поточний баланс, дата останнього поповнення |
| 9. Перегляд списку здійснених поїздок | ID користувача | Список поїздок (дата, номер маршруту, вартість) |
| 10. Перегляд штрафів | ID користувача | Список (Штраф, сума, статус, ID штрафу), загальна кількість штрафів |
| 11. Оскарження штрафу | | |
| 11.1 Пошук штрафу за номером | ID штрафу, ID користувача | Інформація про штраф: причина, сума, статус |
| 11.2 Оскарження штрафу | ID штрафу, ID користувача, пояснення | Статус: «Розглядається», «Відхилено» чи «Задоволено» |
| **Водій** | | |
| 1. Перегляд робочого графіка | ID користувача | Список (номер маршруту, номер транспорту, час відправлення, список зупинок, час закінчення маршруту) |
| 2. Перегляд маршруту | | |
| 2.1 Перегляд зупинок маршруту | Номер маршруту | Список зупинок: ID зупинки, назва зупинки, координати зупинки |
| 2.2 Перегляд маршруту (для відображення на карті) | Номер маршруту | Список точок між зупинками: координати кожної точки на маршруті |
| 3. Початок та завершення рейсу | | |
| 3.1 Відмітка «Початок рейсу» | ID користувача, номер транспорту, час | |
| 3.2 Відмітка «Завершення рейсу» | ID користувача, номер транспорту, час | |
| 4. Введення кількості пасажирів на маршруті | Номер маршруту, тип транспорту, номер транспорту, дата | |

Продовження таблиці 1.1

| Задачі | Вхідна інформація | Вихідна інформація |
| ----- | ----- | ----- |
| **Диспетчер** | | |
| 1. Формування/оновлення розкладу | | |
| 1.1 Створення нового розкладу | Номер маршруту, час відправлення, інтервал, транспорт | ID розкладу |
| 1.2 Редагування наявного розкладу | ID розкладу, оновлена інформація | |
| 2. Перегляд конкретного розкладу | ID розкладу | Список (номер маршруту, номер транспорту, час відправлення, список зупинок) |
| 3. Призначення водія на маршрут | ID водія, номер транспорту, номер маршруту | |
| 4. Контроль за виконанням графіка | | |
| 4.1 Моніторинг позиції транспорту | Номер транспорту, номер маршруту | Координати кожної точки на маршруті, поточні координати транспорту |
| 4.2 Виявлення відхилень від розкладу | ID транспорту, поточний час, координати | Різниця в часі між плановим та поточним часом |
| **Контролер** | | |
| 1. Перевірка транспортної картки | ID транспортної картки | Дані про останню поїздку (ID картки, дата, номер маршруту) |
| 2. Реєстрація штрафу | Номер картки або документи, номер маршруту, номер транспорту, час, причина | ID штрафу, сума, статус «очікує сплати» |
| **Бухгалтер** | | |
| 1. Управління бюджетом | | |
| 1.1 Введення/коригування місячного бюджету | Витрати і доходи | Бюджет |
| 1.2 Облік витрат (пальне, запчастини, ремонт) | Документи/накладні, сума, дата | |
| 1.3 Облік доходів | Дані про транзакції, оплати штрафів | |
| 2. Облік заробітної плати | | |
| 2.1 Нарахування зарплати водіям | ID працівника, ставка, кількість годин | Сума нарахувань |
| 2.2 Аналіз підсумків з/п за період | Період, категорія працівників | Загальна сума виданих зарплат |
| 3. Формування фінансових звітів | | |
| 3.1 Аналітика доходів та витрат | Період | Доходи і витрати за вказаний період |

Продовження таблиці 1.1

| Задачі | Вхідна інформація | Вихідна інформація |
| ----- | ----- | ----- |
| **Департамент мерії** | | |
| 1. Проектування нового маршруту | Координати зупинок, посилання на наступну зупинку, координати точок маршруту | ID маршруту |
| 2. Створення зупинок | Назва зупинки, координати (довгота, широта) | ID зупинки |
| 3. Аналітика пасажиро-потоку | Період, номер маршруту, тип транспорту | Список (Дата, номер транспорту, кількість пасажирів) |
| 4. Перегляд скарг та пропозицій | Період, номер маршруту, тип транспорту | Список: скарга/пропозиція, дата |
| **Менеджер** | | |
| 1. Прийняття на роботу водіїв | Паспортні дані, номер посвідчення, категорії, ПІБ, телефон, email | ID водія |
| 2. Додавання транспорту | Тип транспорту, номер транспорту, номер маршруту, місткість | ID транспорту |
| 3. Створення нових акаунтів для персоналу | Логін, пароль, тип | |

# 2 **ПРОЄКТУВАННЯ ІНФОРМАЦІЙНОЇ СИСТЕМИ** {#проєктування-інформаційної-системи}

У розроблюваній інформаційній системі управління міським транспортом застосовано трирівневу клієнт-серверну архітектуру з використанням патерну проєктування MVC (Model–View–Controller). Особливістю системи є реалізація концепції «товстої бази даних» (thick database), де значна частина бізнес-логіки винесена на рівень СУБД у вигляді збережених процедур та функцій.

## 2.1 **Обґрунтування вибору архітектури** {#обґрунтування-вибору-архітектури}

Трирівнева архітектура складається з трьох основних шарів:

1. **Шар представлення** — відповідає за взаємодію з користувачем. У цій системі він реалізований у вигляді SPA (Single Page Application) на базі React 19, що забезпечує інтерактивний інтерфейс для перегляду маршрутів, розкладів, управління транспортними картками та виконання адміністративних функцій.

2. **Шар бізнес-логіки** — реалізує правила обробки даних. У даному проєкті цей шар розподілений між сервером додатків (NestJS) та сервером бази даних (PostgreSQL). Серверна частина на NestJS відповідає за автентифікацію, маршрутизацію запитів та управління сесіями, тоді як складна бізнес-логіка (розрахунок відстаней, обробка фінансових операцій) реалізована безпосередньо в PostgreSQL.

3. **Шар даних** — забезпечує збереження, оновлення та вибірку інформації. У проєкті використовується СУБД PostgreSQL 16 з розширеннями PostGIS для геопросторових операцій та pgRouting для маршрутизації.

Поділ системи на три рівні з винесенням бізнес-логіки на рівень БД дозволяє забезпечити:
- незалежність компонентів та можливість їх окремого масштабування;
- централізований контроль цілісності даних незалежно від клієнтського ПЗ;
- підвищену безпеку через розмежування доступу на рівні ролей PostgreSQL;
- спрощення клієнтської частини, яка виступає лише «тонким клієнтом».

Схему трирівневої архітектури наведено на рисунку 2.1:

**[ВСТАВИТИ ДІАГРАМУ: схема трирівневої архітектури з клієнтом (React), сервером додатків (NestJS), Redis для сесій та PostgreSQL з розширеннями PostGIS/pgRouting]**

Рисунок 2.1 – Схема трирівневої архітектури системи «Міський транспорт»

## 2.2 **Обґрунтування вибору шаблону проєктування** {#обґрунтування-вибору-шаблону-проєктування}

Для програмної реалізації системи застосовано шаблон MVC (Model–View–Controller), який логічно відповідає трирівневій архітектурі.

**Модель (Model)** — описує структуру даних та операції, пов'язані з ними. У даному проєкті модель реалізована через Drizzle ORM для визначення схем таблиць та взаємодії з PostgreSQL. Особливістю є те, що складні операції (наприклад, купівля квитка з перевіркою балансу та створенням транзакції) виконуються через SECURITY DEFINER функції безпосередньо в БД.

**Представлення (View)** — забезпечує візуальне відображення інформації користувачеві. Цей компонент реалізовано на React 19 з використанням TanStack Router для маршрутизації та Zustand для управління станом. Інтерфейс включає карти на базі MapLibre GL для візуалізації маршрутів та зупинок.

**Контролер (Controller)** — обробляє запити користувачів та керує потоками даних. У NestJS контролери організовані за ролями користувачів:
- `CtGuestController` — для незареєстрованих користувачів;
- `CtPassengerController` — для зареєстрованих пасажирів;
- `CtDriverController` — для водіїв;
- `CtDispatcherController` — для диспетчерів;
- та інші для кожної ролі.

**[ВСТАВИТИ ДІАГРАМУ: схема взаємодії компонентів MVC з показом потоку даних від React через NestJS до PostgreSQL]**

Рисунок 2.2 – Схема взаємодії компонентів MVC

Застосування MVC-патерну дозволяє:
- розділити логіку представлення та обробки даних;
- забезпечити різне представлення для кожної ролі користувача;
- спростити тестування окремих компонентів;
- підтримувати подальше розширення системи без порушення існуючої структури.

# 3 **ІНФОРМАЦІЙНЕ МОДЕЛЮВАННЯ ПРЕДМЕТНОЇ ОБЛАСТІ** {#інформаційне-моделювання-предметної-області}

Опис сутностей розглянутої предметної області, їх атрибутів і обмежень представлено в таблиці 3.1.

Таблиця 3.1 – Опис сутностей предметної області

| Властивість | Опис | Обмеження |
| ----- | ----- | ----- |
| **users** | | |
| id | Ідентифікатор користувача | PRIMARY KEY (PK), BIGSERIAL |
| login | Логін користувача | NOT NULL, UNIQUE |
| email | Електронна пошта | NOT NULL |
| phone | Номер телефону | NOT NULL |
| full_name | Повне ім'я | NOT NULL |
| registered_at | Дата реєстрації | NOT NULL, DEFAULT NOW() |
| **drivers** | | |
| id | Ідентифікатор водія | PK, BIGSERIAL |
| login | Логін для входу | NOT NULL, UNIQUE |
| email | Електронна пошта | |
| phone | Номер телефону | |
| full_name | Повне ім'я водія | NOT NULL |
| driver_license_number | Номер водійського посвідчення | NOT NULL |
| license_categories | Категорії посвідчення | JSONB |
| passport_data | Паспортні дані | JSONB |
| **transport_types** | | |
| id | Ідентифікатор типу транспорту | PK, BIGSERIAL |
| name | Назва типу (автобус, тролейбус, трамвай) | NOT NULL, UNIQUE |
| **routes** | | |
| id | Ідентифікатор маршруту | PK, BIGSERIAL |
| transport_type_id | Тип транспорту | FK → transport_types(id), NOT NULL |
| number | Номер маршруту | NOT NULL |
| direction | Напрямок (forward/reverse) | NOT NULL, CHECK |
| is_active | Чи активний маршрут | NOT NULL, DEFAULT TRUE |

Продовження таблиці 3.1

| Властивість | Опис | Обмеження |
| ----- | ----- | ----- |
| **stops** | | |
| id | Ідентифікатор зупинки | PK, BIGSERIAL |
| name | Назва зупинки | NOT NULL |
| lon | Довгота | NUMERIC, NOT NULL |
| lat | Широта | NUMERIC, NOT NULL |
| **route_stops** | | |
| id | Ідентифікатор | PK, BIGSERIAL |
| route_id | Маршрут | FK → routes(id), NOT NULL |
| stop_id | Зупинка | FK → stops(id), NOT NULL |
| prev_route_stop_id | Попередня зупинка на маршруті | FK → route_stops(id) |
| next_route_stop_id | Наступна зупинка на маршруті | FK → route_stops(id) |
| distance_to_next_km | Відстань до наступної зупинки | NUMERIC(10,3) |
| **route_points** | | |
| id | Ідентифікатор точки | PK, BIGSERIAL |
| route_id | Маршрут | FK → routes(id), NOT NULL |
| lon | Довгота | NUMERIC, NOT NULL |
| lat | Широта | NUMERIC, NOT NULL |
| prev_route_point_id | Попередня точка | FK → route_points(id) |
| next_route_point_id | Наступна точка | FK → route_points(id) |
| **vehicles** | | |
| id | Ідентифікатор транспортного засобу | PK, BIGSERIAL |
| fleet_number | Бортовий номер | NOT NULL, UNIQUE |
| vehicle_model_id | Модель | FK → vehicle_models(id) |
| route_id | Маршрут | FK → routes(id), NOT NULL |
| last_lon | Остання довгота GPS | NUMERIC |
| last_lat | Остання широта GPS | NUMERIC |
| last_recorded_at | Час останнього запису GPS | TIMESTAMP |
| **vehicle_models** | | |
| id | Ідентифікатор моделі | PK, SERIAL |
| name | Назва моделі | NOT NULL |
| type_id | Тип транспорту | FK → transport_types(id), NOT NULL |
| capacity | Місткість | NOT NULL |

Продовження таблиці 3.1

| Властивість | Опис | Обмеження |
| ----- | ----- | ----- |
| **driver_vehicle_assignments** | | |
| id | Ідентифікатор призначення | PK, BIGSERIAL |
| driver_id | Водій | FK → drivers(id), NOT NULL |
| vehicle_id | Транспортний засіб | FK → vehicles(id), NOT NULL |
| assigned_at | Дата призначення | NOT NULL, DEFAULT NOW() |
| **schedules** | | |
| id | Ідентифікатор розкладу | PK, BIGSERIAL |
| route_id | Маршрут | FK → routes(id), NOT NULL |
| vehicle_id | Транспорт | FK → vehicles(id) |
| work_start_time | Час початку роботи | TIME, NOT NULL |
| work_end_time | Час закінчення роботи | TIME, NOT NULL, CHECK > start |
| interval_min | Інтервал руху (хвилини) | INTEGER, NOT NULL, CHECK > 0 |
| monday-sunday | Дні тижня | BOOLEAN, DEFAULT FALSE |
| valid_from | Дата початку дії | DATE |
| valid_to | Дата закінчення дії | DATE |
| **trips** | | |
| id | Ідентифікатор рейсу | PK, BIGSERIAL |
| route_id | Маршрут | FK → routes(id), NOT NULL |
| driver_id | Водій | FK → drivers(id), NOT NULL |
| planned_starts_at | Плановий час початку | TIMESTAMP, NOT NULL |
| planned_ends_at | Плановий час закінчення | TIMESTAMP |
| actual_starts_at | Фактичний час початку | TIMESTAMP |
| actual_ends_at | Фактичний час закінчення | TIMESTAMP |
| status | Статус рейсу | TEXT, CHECK IN ('scheduled', 'in_progress', 'completed', 'cancelled') |
| passenger_count | Кількість пасажирів | INTEGER, DEFAULT 0, CHECK >= 0 |

Продовження таблиці 3.1

| Властивість | Опис | Обмеження |
| ----- | ----- | ----- |
| **transport_cards** | | |
| id | Ідентифікатор картки | PK, BIGSERIAL |
| user_id | Власник картки | FK → users(id), NOT NULL |
| balance | Баланс | NUMERIC(12,2), DEFAULT 0, CHECK >= 0 |
| card_number | Номер картки | TEXT, NOT NULL, UNIQUE |
| **card_top_ups** | | |
| id | Ідентифікатор поповнення | PK, BIGSERIAL |
| card_id | Картка | FK → transport_cards(id), NOT NULL |
| amount | Сума поповнення | NUMERIC(12,2), NOT NULL, CHECK > 0 |
| topped_up_at | Дата поповнення | TIMESTAMP, DEFAULT NOW() |
| **tickets** | | |
| id | Ідентифікатор квитка | PK, BIGSERIAL |
| trip_id | Рейс | FK → trips(id), NOT NULL |
| card_id | Картка | FK → transport_cards(id), NOT NULL |
| price | Вартість | NUMERIC(12,2), NOT NULL, CHECK >= 0 |
| purchased_at | Дата придбання | TIMESTAMP, DEFAULT NOW() |
| **fines** | | |
| id | Ідентифікатор штрафу | PK, BIGSERIAL |
| user_id | Користувач | FK → users(id), NOT NULL |
| trip_id | Рейс | FK → trips(id) |
| amount | Сума штрафу | NUMERIC(12,2), NOT NULL, CHECK > 0 |
| reason | Причина | TEXT, NOT NULL |
| status | Статус | TEXT, DEFAULT 'Очікує сплати' |
| issued_at | Дата видачі | TIMESTAMP, DEFAULT NOW() |
| issued_by | Ким видано | TEXT (session_user) |
| **fine_appeals** | | |
| id | Ідентифікатор апеляції | PK, BIGSERIAL |
| fine_id | Штраф | FK → fines(id), NOT NULL |
| reason | Причина оскарження | TEXT, NOT NULL |
| status | Статус | TEXT, DEFAULT 'Подано' |
| created_at | Дата створення | TIMESTAMP, DEFAULT NOW() |

Продовження таблиці 3.1

| Властивість | Опис | Обмеження |
| ----- | ----- | ----- |
| **complaints_suggestions** | | |
| id | Ідентифікатор | PK, BIGSERIAL |
| type | Тип (скарга/пропозиція) | TEXT, NOT NULL |
| message | Текст повідомлення | TEXT, NOT NULL |
| route_id | Маршрут | FK → routes(id) |
| vehicle_id | Транспорт | FK → vehicles(id) |
| status | Статус | TEXT, DEFAULT 'Подано' |
| contact_info | Контактна інформація | TEXT |
| created_at | Дата створення | TIMESTAMP, DEFAULT NOW() |
| **budgets** | | |
| id | Ідентифікатор бюджету | PK, BIGSERIAL |
| month | Місяць | DATE, NOT NULL, UNIQUE |
| income | Доходи | NUMERIC(14,2), DEFAULT 0 |
| expenses | Витрати | NUMERIC(14,2), DEFAULT 0 |
| note | Примітки | TEXT |
| **expenses** | | |
| id | Ідентифікатор витрати | PK, BIGSERIAL |
| category | Категорія | TEXT, NOT NULL |
| amount | Сума | NUMERIC(12,2), NOT NULL, CHECK > 0 |
| description | Опис | TEXT |
| document_ref | Посилання на документ | TEXT |
| occurred_at | Дата | TIMESTAMP, DEFAULT NOW() |
| **salary_payments** | | |
| id | Ідентифікатор виплати | PK, BIGSERIAL |
| driver_id | Водій | FK → drivers(id), NOT NULL |
| rate | Ставка | NUMERIC(12,2) |
| units | Одиниці (години) | INTEGER, CHECK > 0 |
| total | Загальна сума | NUMERIC(12,2), NOT NULL, CHECK > 0 |
| paid_at | Дата виплати | TIMESTAMP, DEFAULT NOW() |
| **vehicle_gps_logs** | | |
| id | Ідентифікатор запису | PK, BIGSERIAL |
| vehicle_id | Транспорт | FK → vehicles(id), NOT NULL |
| lon | Довгота | NUMERIC, NOT NULL |
| lat | Широта | NUMERIC, NOT NULL |
| recorded_at | Час запису | TIMESTAMP, DEFAULT NOW() |

**Опис зв'язків між сутностями:**

1. **Зв'язок між маршрутами та типами транспорту.** Один тип транспорту (автобус, тролейбус, трамвай) може мати багато маршрутів. З іншого боку, кожен маршрут належить лише одному типу транспорту. Отже, між таблицями transport_types та routes існує зв'язок один-до-багатьох.

2. **Зв'язок між маршрутами та зупинками.** Один маршрут проходить через багато зупинок, і одна зупинка може належати до багатьох маршрутів. Для формалізації цього зв'язку багато-до-багатьох створена проміжна таблиця route_stops, яка також зберігає порядок зупинок через зв'язаний список (prev/next).

3. **Зв'язок між маршрутами та точками.** Кожен маршрут має багато геометричних точок для відображення на карті. Таблиця route_points реалізує цей зв'язок один-до-багатьох із збереженням порядку через зв'язаний список.

4. **Зв'язок між транспортними засобами та маршрутами.** Кожен транспортний засіб закріплений за одним маршрутом, але маршрут може обслуговуватися багатьма транспортними засобами. Зв'язок один-до-багатьох.

5. **Зв'язок між водіями та транспортними засобами.** Водій призначається на транспортний засіб через таблицю driver_vehicle_assignments. Один водій може мати кілька призначень (історично), і один транспорт може мати різних водіїв. Зв'язок багато-до-багатьох.

6. **Зв'язок між рейсами та водіями.** Кожен рейс виконується одним водієм, але водій може виконати багато рейсів. Зв'язок один-до-багатьох.

7. **Зв'язок між транспортними картками та користувачами.** Кожна картка належить одному користувачу, але користувач може мати кілька карток. Зв'язок один-до-багатьох.

8. **Зв'язок між квитками, картками та рейсами.** Квиток пов'язує конкретну картку з конкретним рейсом, фіксуючи факт оплати проїзду. Кожен квиток має один рейс та одну картку, але рейс та картка можуть мати багато квитків.

9. **Зв'язок між штрафами та апеляціями.** Один штраф може мати кілька апеляцій (якщо попередні були відхилені). Зв'язок один-до-багатьох.

Усі таблиці знаходяться у нормальній формі Бойса-Кодда. Схему бази даних, що ілюструє сутності та зв'язки між ними, наведено в додатку А (рис. А.1).

**[ВСТАВИТИ ДІАГРАМУ: ER-діаграма бази даних з усіма таблицями та зв'язками]**

# 4 **ПРОГРАМНА МОДЕЛЬ ЗАСТОСУНКУ** {#програмна-модель-застосунку}

Усі користувачі системи працюють з єдиним веб-застосунком, але залежно від своєї ролі мають доступ до різних функцій та сторінок. Frontend-додаток реактивно адаптує інтерфейс на основі ролей користувача, отриманих під час автентифікації.

На рисунку 4.1 наведена UML-діаграма класів рівня моделей даних (Drizzle ORM схеми) із зазначенням атрибутів:

**[ВСТАВИТИ ДІАГРАМУ: UML-діаграма класів моделей даних - users, drivers, routes, stops, vehicles, trips, transport_cards, tickets, fines та інші]**

Рисунок 4.1 – Діаграма моделей даних інформаційної системи з атрибутами

Усі модельні класи застосунку використовуються як схеми Drizzle ORM для забезпечення типобезпечної взаємодії з базою даних. Атрибути кожного класу відповідають полям відповідних таблиць PostgreSQL.

На рисунку 4.2 наведена ієрархія веб-сторінок фронтенд-додатку:

**[ВСТАВИТИ ДІАГРАМУ: ієрархія сторінок - головна, login, register, та гілки для кожної ролі: passenger/, driver/, dispatcher/, controller/, manager/, municipality/, accountant/]**

Рисунок 4.2 – Ієрархія веб-сторінок фронтенд застосунку

Основні маршрути системи:
- `/` — головна сторінка з пошуком маршрутів
- `/login` — сторінка входу
- `/register` — реєстрація пасажирів
- `/map` — карта маршрутів
- `/passenger/*` — особистий кабінет пасажира
- `/driver/*` — робоче місце водія
- `/dispatcher/*` — панель диспетчера
- `/controller/*` — панель контролера
- `/manager/*` — панель менеджера
- `/municipality/*` — панель департаменту мерії
- `/accountant/*` — панель бухгалтера

На рисунку 4.3 наведена діаграма сервісів бекенд-додатку:

**[ВСТАВИТИ ДІАГРАМУ: діаграма класів сервісів NestJS - AuthService, DbService, SessionService та рольові сервіси]**

Рисунок 4.3 – Діаграма сервісів інформаційної системи

Ключові сервіси системи:
- **AuthService** — автентифікація та авторизація користувачів
- **SessionService** — управління сесіями в Redis
- **DbService** — динамічне створення пулів з'єднань для кожного користувача
- **RequestContextService** — зберігання контексту запиту через AsyncLocalStorage

На рисунку 4.4 наведена діаграма контролерів:

**[ВСТАВИТИ ДІАГРАМУ: діаграма класів контролерів - CtGuestController, CtPassengerController, CtDriverController, CtDispatcherController, CtControllerController, CtManagerController, CtMunicipalityController, CtAccountantController]**

Рисунок 4.4 – Діаграма контролерів інформаційної системи

# 5 **ВИБІР ПРОГРАМНОГО ЗАБЕЗПЕЧЕННЯ** {#вибір-програмного-забезпечення}

Для створення інформаційної системи обрано набір сучасних технологій, що забезпечують надійність, продуктивність та масштабованість.

**База даних — PostgreSQL 16:**
- Найрозвиненіша реляційна СУБД з відкритим кодом;
- Підтримка розширень PostGIS для геопросторових операцій (розрахунок відстаней, пошук найближчих зупинок);
- Підтримка pgRouting для оптимальної маршрутизації;
- Розвинена система ролей для розмежування доступу;
- SECURITY DEFINER функції для реалізації бізнес-логіки на рівні БД;
- Підтримка JSONB для зберігання гнучких структур (паспортні дані, категорії посвідчень).

**Backend — NestJS 11:**
- Модульна архітектура для організації коду за функціональними блоками;
- Вбудована підтримка TypeScript для типобезпеки;
- Декоратори для визначення маршрутів, валідації та авторизації;
- Інтеграція з Passport для JWT-автентифікації;
- Підтримка middleware та interceptors для обробки запитів.

**ORM — Drizzle:**
- Типобезпечний SQL-builder для TypeScript;
- Генерація міграцій з коду;
- Підтримка сирих SQL-запитів для складних операцій;
- Мінімальний overhead порівняно з традиційними ORM.

**Кешування сесій — Redis:**
- Зберігання JWT-токенів та даних сесій;
- Висока швидкість читання/запису;
- Автоматичне видалення застарілих сесій.

**Frontend — React 19 + Vite 7:**
- Компонентний підхід для побудови інтерфейсу;
- TanStack Router для типобезпечної маршрутизації;
- TanStack Query для кешування та синхронізації серверних даних;
- Zustand для управління глобальним станом;
- MapLibre GL для візуалізації карт та маршрутів;
- Tailwind CSS для стилізації;
- React Hook Form + Zod для валідації форм.

**Контейнеризація — Docker:**
- Docker Compose для оркестрації PostgreSQL та Redis;
- Ізольоване середовище для тестування.

**Інструменти розробки:**
- WebStorm/IntelliJ IDEA — IDE для TypeScript та Node.js;
- pgAdmin/Valentina Studio — клієнти для роботи з PostgreSQL;
- Postman — тестування REST API;
- Git — контроль версій.

# 6 **СТВОРЕННЯ БАЗИ ДАНИХ** {#створення-бази-даних}

У цьому розділі наведено приклади формування основних об'єктів БД. Повний текст запитів ініціалізації наведено у додатках Б та В.

## 6.1 **Приклад створення таблиці** {#приклад-створення-таблиці}

Таблиця users демонструє базову структуру користувачів системи (лістинг 6.1):

```sql
CREATE TABLE public.users (
    id BIGSERIAL PRIMARY KEY,
    login TEXT NOT NULL UNIQUE,
    email TEXT NOT NULL,
    phone TEXT NOT NULL,
    full_name TEXT NOT NULL,
    registered_at TIMESTAMP WITHOUT TIME ZONE DEFAULT NOW() NOT NULL
);
```

Лістинг 6.1 – Запит створення таблиці users

Первинний ключ типу BIGSERIAL забезпечує автоматичну генерацію унікальних ідентифікаторів. Обмеження UNIQUE на login гарантує відсутність дублікатів логінів.

## 6.2 **Приклад створення таблиці із зовнішніми ключами** {#приклад-створення-таблиці-із-зовнішніми-ключами}

Таблиця routes ілюструє використання зовнішніх ключів та CHECK-обмежень (лістинг 6.2):

```sql
CREATE TABLE public.routes (
    id BIGSERIAL PRIMARY KEY,
    transport_type_id BIGINT NOT NULL
        REFERENCES public.transport_types(id),
    number TEXT NOT NULL,
    direction TEXT NOT NULL,
    is_active BOOLEAN DEFAULT TRUE NOT NULL,
    CONSTRAINT routes_direction_check
        CHECK (direction = ANY (ARRAY['forward', 'reverse']))
);
```

Лістинг 6.2 – Запит створення таблиці routes

CHECK-обмеження гарантує, що напрямок маршруту може бути лише 'forward' або 'reverse'.

## 6.3 **Приклад реалізації зв'язку «багато-до-багатьох»** {#приклад-реалізації-звязку-багато-до-багатьох}

Таблиця driver_vehicle_assignments реалізує зв'язок між водіями та транспортними засобами (лістинг 6.3):

```sql
CREATE TABLE public.driver_vehicle_assignments (
    id BIGSERIAL PRIMARY KEY,
    driver_id BIGINT NOT NULL
        REFERENCES public.drivers(id),
    vehicle_id BIGINT NOT NULL
        REFERENCES public.vehicles(id),
    assigned_at TIMESTAMP WITHOUT TIME ZONE DEFAULT NOW() NOT NULL
);
```

Лістинг 6.3 – Запит створення таблиці driver_vehicle_assignments

Таблиця зберігає історію призначень водіїв на транспортні засоби з фіксацією дати призначення.

## 6.4 **Створення ролей та схем API** {#створення-ролей-та-схем-api}

Особливістю системи є використання окремих PostgreSQL-ролей та схем для кожного типу користувача. Це забезпечує розмежування доступу на рівні бази даних (лістинг 6.4):

```sql
-- Створення базових ролей
CREATE ROLE ct_guest_role NOLOGIN;
CREATE ROLE ct_passenger_role NOLOGIN;
CREATE ROLE ct_driver_role NOLOGIN;
CREATE ROLE ct_dispatcher_role NOLOGIN;
CREATE ROLE ct_controller_role NOLOGIN;
CREATE ROLE ct_manager_role NOLOGIN;
CREATE ROLE ct_municipality_role NOLOGIN;
CREATE ROLE ct_accountant_role NOLOGIN;

-- Створення схем API для кожної ролі
CREATE SCHEMA guest_api;
CREATE SCHEMA passenger_api;
CREATE SCHEMA driver_api;
CREATE SCHEMA dispatcher_api;
CREATE SCHEMA controller_api;
CREATE SCHEMA manager_api;
CREATE SCHEMA municipality_api;
CREATE SCHEMA accountant_api;

-- Надання прав на схеми
GRANT USAGE ON SCHEMA guest_api TO ct_guest_role;
GRANT USAGE ON SCHEMA passenger_api TO ct_passenger_role;
-- ... і так далі для кожної ролі
```

Лістинг 6.4 – Створення ролей та схем API

Кожна роль має доступ лише до своєї схеми, де розміщені представлення та SECURITY DEFINER функції для виконання дозволених операцій.

Розподіл прав доступу для користувачів бази даних наведено в таблиці 6.1.

Таблиця 6.1 – Розподіл прав доступу

| Схема API | Роль | Основні права |
| ----- | ----- | ----- |
| guest_api | ct_guest_role | SELECT на представлення маршрутів, зупинок, розкладів |
| passenger_api | ct_passenger_role | + функції поповнення картки, купівлі квитків, оскарження штрафів |
| driver_api | ct_driver_role | Функції старту/завершення рейсу, GPS-логування |
| dispatcher_api | ct_dispatcher_role | CRUD розкладів, рейсів, призначень водіїв |
| controller_api | ct_controller_role | Перевірка карток, виписування штрафів |
| manager_api | ct_manager_role | Найм водіїв, створення акаунтів персоналу |
| municipality_api | ct_municipality_role | Створення маршрутів, зупинок, аналітика пасажиропотоку |
| accountant_api | ct_accountant_role | Бюджети, витрати, зарплати, фінансові звіти |

# 7 **ЗАПИТИ ДО БАЗИ ДАНИХ ДЛЯ РОЗВ'ЯЗАННЯ ПОСТАВЛЕНИХ ЗАДАЧ** {#запити-до-бази-даних-для-розвязання-поставлених-задач}

Інформаційна система реалізує бізнес-логіку на стороні сервера бази даних за допомогою збережених функцій (SECURITY DEFINER) та представлень. Це забезпечує високу швидкість виконання операцій, централізований контроль цілісності даних та безпеку.

## 7.1 **Розв'язання задач гостя** {#розвязання-задач-гостя}

**Задача 1: Перегляд найближчих зупинок**

Для пошуку найближчих зупинок за GPS-координатами створено функцію з використанням PostGIS (лістинг 7.1):

```sql
CREATE FUNCTION guest_api.get_nearby_stops(
    p_lon NUMERIC,
    p_lat NUMERIC,
    p_radius_km NUMERIC DEFAULT 0.5
)
RETURNS TABLE(id BIGINT, name TEXT, lon NUMERIC, lat NUMERIC, distance_m NUMERIC)
LANGUAGE SQL STABLE SECURITY DEFINER
SET search_path TO 'public', 'pg_catalog'
AS $$
    SELECT s.id, s.name, s.lon, s.lat,
           ST_DistanceSphere(
               ST_MakePoint(s.lon::float, s.lat::float),
               ST_MakePoint(p_lon::float, p_lat::float)
           )::numeric AS distance_m
    FROM stops s
    WHERE ST_DistanceSphere(
        ST_MakePoint(s.lon::float, s.lat::float),
        ST_MakePoint(p_lon::float, p_lat::float)
    ) <= p_radius_km * 1000
    ORDER BY distance_m;
$$;
```

Лістинг 7.1 – Функція пошуку найближчих зупинок

**Задача 2: Перегляд транспорту через зупинку**

Представлення v_stop_routes_schedule відображає маршрути, що проходять через зупинку (лістинг 7.2):

```sql
CREATE VIEW guest_api.v_stop_routes AS
SELECT DISTINCT rs.stop_id, r.number AS route_number,
       tt.name AS transport_type, r.direction
FROM route_stops rs
JOIN routes r ON r.id = rs.route_id AND r.is_active = true
JOIN transport_types tt ON tt.id = r.transport_type_id;
```

Лістинг 7.2 – Представлення маршрутів через зупинку

**Задача 5: Перегляд розкладу**

Функція get_schedule_departures генерує список часів відправлення на основі інтервалу (лістинг 7.3):

```sql
CREATE FUNCTION guest_api.get_schedule_departures(p_schedule_id BIGINT)
RETURNS TABLE(departure_time TEXT)
LANGUAGE plpgsql STABLE SECURITY DEFINER
AS $$
DECLARE
    v_start TIME; v_end TIME; v_interval INT;
BEGIN
    SELECT work_start_time, work_end_time, interval_min
    INTO v_start, v_end, v_interval
    FROM schedules WHERE id = p_schedule_id;

    RETURN QUERY
    SELECT format_minutes_to_time(
        parse_time_to_minutes(v_start) + (n * v_interval)
    )
    FROM generate_series(0,
        ((parse_time_to_minutes(v_end) - parse_time_to_minutes(v_start)) / v_interval)::int
    ) AS n;
END;
$$;
```

Лістинг 7.3 – Функція генерації часів відправлення

## 7.2 **Розв'язання задач пасажира** {#розвязання-задач-пасажира}

**Задача 8: Поповнення транспортної картки**

Функція top_up_card виконує атомарне поповнення балансу (лістинг 7.4):

```sql
CREATE FUNCTION passenger_api.top_up_card(p_card_id BIGINT, p_amount NUMERIC)
RETURNS BIGINT
LANGUAGE plpgsql SECURITY DEFINER
SET search_path TO 'public', 'pg_catalog'
AS $$
DECLARE v_user_id BIGINT; v_top_up_id BIGINT;
BEGIN
    -- Перевірка власника картки
    SELECT user_id INTO v_user_id FROM transport_cards WHERE id = p_card_id;
    IF (SELECT id FROM users WHERE login = session_user) != v_user_id THEN
        RAISE EXCEPTION 'Not your card';
    END IF;

    -- Оновлення балансу
    UPDATE transport_cards SET balance = balance + p_amount WHERE id = p_card_id;

    -- Створення запису про поповнення
    INSERT INTO card_top_ups (card_id, amount)
    VALUES (p_card_id, p_amount)
    RETURNING id INTO v_top_up_id;

    RETURN v_top_up_id;
END;
$$;
```

Лістинг 7.4 – Функція поповнення картки

**Задача 11: Оскарження штрафу**

Функція create_appeal створює апеляцію з перевіркою статусу штрафу (лістинг 7.5):

```sql
CREATE FUNCTION passenger_api.create_appeal(p_fine_id BIGINT, p_reason TEXT)
RETURNS BIGINT
LANGUAGE plpgsql SECURITY DEFINER
AS $$
DECLARE v_appeal_id BIGINT; v_user_id BIGINT; v_fine_user_id BIGINT;
BEGIN
    SELECT id INTO v_user_id FROM users WHERE login = session_user;
    SELECT user_id INTO v_fine_user_id FROM fines WHERE id = p_fine_id;

    IF v_user_id != v_fine_user_id THEN
        RAISE EXCEPTION 'Not your fine';
    END IF;

    INSERT INTO fine_appeals (fine_id, reason, status)
    VALUES (p_fine_id, p_reason, 'Подано')
    RETURNING id INTO v_appeal_id;

    UPDATE fines SET status = 'Оскаржується' WHERE id = p_fine_id;

    RETURN v_appeal_id;
END;
$$;
```

Лістинг 7.5 – Функція оскарження штрафу

## 7.3 **Розв'язання задач водія** {#розвязання-задач-водія}

**Задача 3: Початок та завершення рейсу**

Функції start_trip та finish_trip управляють статусом рейсу (лістинг 7.6):

```sql
CREATE FUNCTION driver_api.start_trip(
    p_trip_id BIGINT DEFAULT NULL,
    p_started_at TIMESTAMP DEFAULT NOW()
)
RETURNS BIGINT
LANGUAGE plpgsql SECURITY DEFINER
AS $$
DECLARE v_driver_id BIGINT; v_trip_id BIGINT;
BEGIN
    SELECT id INTO v_driver_id FROM drivers WHERE login = session_user;
    IF v_driver_id IS NULL THEN RAISE EXCEPTION 'driver not found'; END IF;

    -- Перевірка активного рейсу
    IF EXISTS (SELECT 1 FROM trips WHERE driver_id = v_driver_id AND status = 'in_progress') THEN
        RAISE EXCEPTION 'Active trip exists. Finish it first.';
    END IF;

    -- Пошук рейсу
    IF p_trip_id IS NOT NULL THEN
        SELECT id INTO v_trip_id FROM trips
        WHERE id = p_trip_id AND driver_id = v_driver_id AND status = 'scheduled';
    ELSE
        SELECT id INTO v_trip_id FROM trips
        WHERE driver_id = v_driver_id AND status = 'scheduled'
          AND planned_starts_at <= now() + interval '30 minutes'
        ORDER BY planned_starts_at LIMIT 1;
    END IF;

    IF v_trip_id IS NULL THEN
        RAISE EXCEPTION 'No scheduled trips found';
    END IF;

    -- Старт рейсу
    UPDATE trips SET status = 'in_progress', actual_starts_at = p_started_at
    WHERE id = v_trip_id;

    RETURN v_trip_id;
END;
$$;
```

Лістинг 7.6 – Функція початку рейсу

**Задача 4: GPS-логування**

Функція log_vehicle_gps записує координати транспорту під час рейсу (лістинг 7.7):

```sql
CREATE FUNCTION driver_api.log_vehicle_gps(
    p_lon NUMERIC, p_lat NUMERIC,
    p_recorded_at TIMESTAMP DEFAULT NOW()
)
RETURNS VOID
LANGUAGE plpgsql SECURITY DEFINER
AS $$
DECLARE v_driver_id BIGINT; v_vehicle_id BIGINT;
BEGIN
    SELECT id INTO v_driver_id FROM drivers WHERE login = session_user;

    -- Перевірка активного рейсу
    IF NOT EXISTS (SELECT 1 FROM trips WHERE driver_id = v_driver_id AND status = 'in_progress') THEN
        RAISE EXCEPTION 'no active trip';
    END IF;

    -- Отримання vehicle_id з призначень
    SELECT dva.vehicle_id INTO v_vehicle_id
    FROM driver_vehicle_assignments dva
    WHERE dva.driver_id = v_driver_id
    ORDER BY dva.assigned_at DESC LIMIT 1;

    IF v_vehicle_id IS NULL THEN RAISE EXCEPTION 'no vehicle assigned'; END IF;

    INSERT INTO vehicle_gps_logs (vehicle_id, lon, lat, recorded_at)
    VALUES (v_vehicle_id, p_lon, p_lat, p_recorded_at);
END;
$$;
```

Лістинг 7.7 – Функція GPS-логування

## 7.4 **Розв'язання задач диспетчера** {#розвязання-задач-диспетчера}

**Задача 1: Створення розкладу**

Функція create_schedule створює новий розклад з валідацією (лістинг 7.8):

```sql
CREATE FUNCTION dispatcher_api.create_schedule(
    p_route_id BIGINT, p_vehicle_id BIGINT,
    p_start TIME, p_end TIME, p_interval INT,
    p_monday BOOLEAN DEFAULT TRUE, p_tuesday BOOLEAN DEFAULT TRUE,
    p_wednesday BOOLEAN DEFAULT TRUE, p_thursday BOOLEAN DEFAULT TRUE,
    p_friday BOOLEAN DEFAULT TRUE, p_saturday BOOLEAN DEFAULT FALSE,
    p_sunday BOOLEAN DEFAULT FALSE,
    p_valid_from DATE DEFAULT NULL, p_valid_to DATE DEFAULT NULL
)
RETURNS BIGINT
LANGUAGE plpgsql SECURITY DEFINER
AS $$
DECLARE v_id BIGINT;
BEGIN
    -- Валідація часу
    IF p_end <= p_start THEN
        RAISE EXCEPTION 'End time must be after start time';
    END IF;

    INSERT INTO schedules (
        route_id, vehicle_id, work_start_time, work_end_time, interval_min,
        monday, tuesday, wednesday, thursday, friday, saturday, sunday,
        valid_from, valid_to
    ) VALUES (
        p_route_id, p_vehicle_id, p_start, p_end, p_interval,
        p_monday, p_tuesday, p_wednesday, p_thursday, p_friday, p_saturday, p_sunday,
        p_valid_from, p_valid_to
    ) RETURNING id INTO v_id;

    RETURN v_id;
END;
$$;
```

Лістинг 7.8 – Функція створення розкладу

**Задача 4: Виявлення відхилень від розкладу**

Представлення v_active_trip_deviations показує рейси з затримками (лістинг 7.9):

```sql
CREATE VIEW dispatcher_api.v_active_trip_deviations AS
SELECT trip_id, route_number, fleet_number, driver_name,
       planned_starts_at, actual_starts_at, delay_minutes
FROM (
    SELECT t.id AS trip_id, r.number AS route_number, v.fleet_number,
           d.full_name AS driver_name, t.planned_starts_at, t.actual_starts_at,
           dispatcher_api.calculate_delay(t.id) AS delay_minutes
    FROM trips t
    JOIN routes r ON r.id = t.route_id
    JOIN drivers d ON d.id = t.driver_id
    LEFT JOIN driver_vehicle_assignments dva ON dva.driver_id = t.driver_id
    LEFT JOIN vehicles v ON v.id = dva.vehicle_id
    WHERE t.status IN ('scheduled', 'in_progress')
) deviations
WHERE ABS(delay_minutes) > 5;
```

Лістинг 7.9 – Представлення відхилень від розкладу

## 7.5 **Розв'язання задач контролера** {#розвязання-задач-контролера}

**Задача 2: Реєстрація штрафу**

Функція issue_fine виписує штраф з прив'язкою до рейсу (лістинг 7.10):

```sql
CREATE FUNCTION controller_api.issue_fine(
    p_card TEXT, p_amt NUMERIC, p_reason TEXT,
    p_fleet TEXT DEFAULT NULL, p_time TIMESTAMP DEFAULT NOW(),
    p_trip_id BIGINT DEFAULT NULL
)
RETURNS BIGINT
LANGUAGE plpgsql SECURITY DEFINER
AS $$
DECLARE v_u_id BIGINT; v_t_id BIGINT; v_f_id BIGINT;
BEGIN
    SELECT user_id INTO v_u_id FROM transport_cards WHERE card_number = p_card;
    IF v_u_id IS NULL THEN RAISE EXCEPTION 'Card not found'; END IF;

    -- Пошук активного рейсу
    IF p_trip_id IS NOT NULL THEN
        SELECT id INTO v_t_id FROM trips WHERE id = p_trip_id AND status = 'in_progress';
        IF v_t_id IS NULL THEN RAISE EXCEPTION 'Trip not in progress'; END IF;
    END IF;

    IF v_t_id IS NULL THEN
        RAISE EXCEPTION 'Cannot issue fine without valid trip';
    END IF;

    -- Створення штрафу з записом контролера
    INSERT INTO fines (user_id, amount, reason, status, trip_id, issued_at, issued_by)
    VALUES (v_u_id, p_amt, p_reason, 'Очікує сплати', v_t_id, p_time, session_user)
    RETURNING id INTO v_f_id;

    RETURN v_f_id;
END;
$$;
```

Лістинг 7.10 – Функція виписування штрафу

## 7.6 **Розв'язання задач менеджера** {#розвязання-задач-менеджера}

**Задача 1: Прийняття на роботу водія**

Функція hire_driver створює PostgreSQL-роль та запис у таблиці водіїв (лістинг 7.11):

```sql
CREATE FUNCTION manager_api.hire_driver(
    p_login TEXT, p_password TEXT, p_email TEXT, p_phone TEXT,
    p_full_name TEXT, p_license_number TEXT,
    p_categories JSONB, p_passport_data JSONB
)
RETURNS BIGINT
LANGUAGE plpgsql SECURITY DEFINER
AS $$
DECLARE v_id BIGINT;
BEGIN
    -- Створення PostgreSQL ролі
    IF NOT EXISTS (SELECT 1 FROM pg_roles WHERE rolname = p_login) THEN
        EXECUTE format('CREATE ROLE %I LOGIN PASSWORD %L', p_login, p_password);
    END IF;
    EXECUTE format('GRANT ct_driver_role TO %I', p_login);

    -- Створення запису водія
    INSERT INTO drivers (login, email, phone, full_name,
                        driver_license_number, license_categories, passport_data)
    VALUES (p_login, p_email, p_phone, p_full_name,
            p_license_number, p_categories, p_passport_data)
    RETURNING id INTO v_id;

    RETURN v_id;
END;
$$;
```

Лістинг 7.11 – Функція найму водія

## 7.7 **Розв'язання задач департаменту мерії** {#розвязання-задач-департаменту-мерії}

**Задача 1: Створення маршруту**

Функція create_route_full створює маршрут з зупинками та точками (лістинг 7.12):

```sql
CREATE FUNCTION municipality_api.create_route_full(
    p_number TEXT, p_transport_type_id INT, p_direction TEXT,
    p_stops_json JSONB, p_points_json JSONB
)
RETURNS BIGINT
LANGUAGE plpgsql SECURITY DEFINER
AS $$
DECLARE v_route_id BIGINT; v_stop RECORD; v_point RECORD;
BEGIN
    -- Створення маршруту
    INSERT INTO routes (number, transport_type_id, direction, is_active)
    VALUES (p_number, p_transport_type_id, p_direction, true)
    RETURNING id INTO v_route_id;

    -- Додавання зупинок з JSONB
    FOR v_stop IN SELECT * FROM jsonb_to_recordset(p_stops_json)
        AS x(stop_id BIGINT, name TEXT, lon NUMERIC, lat NUMERIC, distance_to_next_km NUMERIC)
    LOOP
        -- ... логіка створення route_stops ...
    END LOOP;

    -- Додавання точок маршруту
    FOR v_point IN SELECT * FROM jsonb_to_recordset(p_points_json)
        AS x(lon NUMERIC, lat NUMERIC)
    LOOP
        -- ... логіка створення route_points ...
    END LOOP;

    -- Перерахунок відстаней через PostGIS
    PERFORM municipality_api.recalculate_route_stop_distances(v_route_id);

    RETURN v_route_id;
END;
$$;
```

Лістинг 7.12 – Функція створення маршруту

**Задача 3: Аналітика пасажиропотоку**

Функція get_passenger_flow повертає статистику за період (лістинг 7.13):

```sql
CREATE FUNCTION municipality_api.get_passenger_flow(
    p_start_date DATE, p_end_date DATE,
    p_route_number TEXT DEFAULT NULL, p_transport_type TEXT DEFAULT NULL
)
RETURNS TABLE(trip_date DATE, route_number TEXT, transport_type TEXT,
              fleet_number TEXT, passenger_count INT)
LANGUAGE plpgsql STABLE SECURITY DEFINER
AS $$
BEGIN
    RETURN QUERY
    SELECT t.actual_starts_at::date, r.number, tt.name, v.fleet_number, t.passenger_count
    FROM trips t
    JOIN routes r ON r.id = t.route_id
    JOIN transport_types tt ON tt.id = r.transport_type_id
    LEFT JOIN driver_vehicle_assignments dva ON dva.driver_id = t.driver_id
    LEFT JOIN vehicles v ON v.id = dva.vehicle_id
    WHERE t.status = 'completed'
      AND t.actual_starts_at >= p_start_date AND t.actual_starts_at < p_end_date + 1
      AND (p_route_number IS NULL OR r.number = p_route_number)
      AND (p_transport_type IS NULL OR tt.name = p_transport_type)
    ORDER BY t.actual_starts_at DESC;
END;
$$;
```

Лістинг 7.13 – Функція аналітики пасажиропотоку

## 7.8 **Розв'язання задач бухгалтера** {#розвязання-задач-бухгалтера}

**Задача 3: Фінансовий звіт**

Функція get_financial_report агрегує доходи та витрати за період (лістинг 7.14):

```sql
CREATE FUNCTION accountant_api.get_financial_report(p_start_date DATE, p_end_date DATE)
RETURNS TABLE(category TEXT, amount NUMERIC, type TEXT)
LANGUAGE plpgsql STABLE SECURITY DEFINER
AS $$
BEGIN
    -- Доходи від квитків
    RETURN QUERY SELECT 'Квитки'::text, COALESCE(SUM(price), 0), 'income'::text
    FROM tickets WHERE purchased_at >= p_start_date AND purchased_at < p_end_date + 1;

    -- Доходи від поповнень
    RETURN QUERY SELECT 'Поповнення карток'::text, COALESCE(SUM(amount), 0), 'income_flow'::text
    FROM card_top_ups WHERE topped_up_at >= p_start_date AND topped_up_at < p_end_date + 1;

    -- Доходи від штрафів
    RETURN QUERY SELECT 'Штрафи'::text, COALESCE(SUM(amount), 0), 'income'::text
    FROM fines WHERE status = 'Оплачено' AND issued_at >= p_start_date AND issued_at < p_end_date + 1;

    -- Витрати по категоріях
    RETURN QUERY SELECT e.category, COALESCE(SUM(e.amount), 0), 'expense'::text
    FROM expenses e WHERE e.occurred_at >= p_start_date AND e.occurred_at < p_end_date + 1
    GROUP BY e.category;

    -- Зарплати
    RETURN QUERY SELECT 'Зарплата'::text, COALESCE(SUM(total), 0), 'expense'::text
    FROM salary_payments WHERE paid_at >= p_start_date AND paid_at < p_end_date + 1;
END;
$$;
```

Лістинг 7.14 – Функція фінансового звіту

# 8 **ПРОГРАМНА РЕАЛІЗАЦІЯ ІНТЕРФЕЙСУ** {#програмна-реалізація-інтерфейсу}

## 8.1 **Реалізація бекенд-додатку** {#реалізація-бекенд-додатку}

Бекенд-додаток побудовано на NestJS з модульною архітектурою. Кожна роль користувача має окремий модуль з контролером та сервісом.

**Контролер для гостя** (лістинг 8.1):

```typescript
@Controller('ct-guest')
export class CtGuestController {
  constructor(private readonly ctGuestService: CtGuestService) {}

  @Get('stops/nearby')
  async getNearbyStops(
    @Query('lon') lon: string,
    @Query('lat') lat: string,
    @Query('radius') radius?: string,
  ) {
    return this.ctGuestService.getNearbyStops(
      parseFloat(lon),
      parseFloat(lat),
      radius ? parseFloat(radius) : 0.5
    );
  }

  @Get('routes/:id/stops')
  async getRouteStops(@Param('id') id: string) {
    return this.ctGuestService.getRouteStops(parseInt(id));
  }

  @Get('routes/:id/points')
  async getRoutePoints(@Param('id') id: string) {
    return this.ctGuestService.getRoutePoints(parseInt(id));
  }

  @Get('schedules/:routeId')
  async getSchedule(@Param('routeId') routeId: string) {
    return this.ctGuestService.getSchedule(parseInt(routeId));
  }
}
```

Лістинг 8.1 – Контролер CtGuestController

**Сервіс DbService** забезпечує динамічне створення пулів з'єднань для кожного користувача (лістинг 8.2):

```typescript
@Injectable()
export class DbService {
  private pools: Map<string, Pool> = new Map();

  constructor(
    private readonly config: ConfigService,
    private readonly requestContext: RequestContextService,
  ) {}

  async getConnection(): Promise<Pool> {
    const ctx = this.requestContext.get();
    if (!ctx?.login) {
      throw new UnauthorizedException('No session context');
    }

    const key = ctx.login;
    if (!this.pools.has(key)) {
      const pool = new Pool({
        host: this.config.get('DB_HOST'),
        port: this.config.get('DB_PORT'),
        database: this.config.get('DB_NAME'),
        user: ctx.login,
        password: ctx.password,
        max: 5,
      });
      this.pools.set(key, pool);
    }

    return this.pools.get(key)!;
  }

  async query<T>(sql: string, params?: any[]): Promise<T[]> {
    const pool = await this.getConnection();
    const result = await pool.query(sql, params);
    return result.rows as T[];
  }
}
```

Лістинг 8.2 – Сервіс DbService для управління з'єднаннями

**Контролер водія** (лістинг 8.3):

```typescript
@Controller('ct-driver')
@UseGuards(JwtAuthGuard, RolesGuard)
@Roles('ct_driver_role')
export class CtDriverController {
  constructor(private readonly ctDriverService: CtDriverService) {}

  @Get('schedule')
  async getSchedule() {
    return this.ctDriverService.getMySchedule();
  }

  @Post('trip/start')
  async startTrip(@Body() dto: StartTripDto) {
    return this.ctDriverService.startTrip(dto.tripId);
  }

  @Post('trip/finish')
  async finishTrip() {
    return this.ctDriverService.finishTrip();
  }

  @Post('gps')
  async logGps(@Body() dto: GpsLogDto) {
    return this.ctDriverService.logGps(dto.lon, dto.lat);
  }

  @Patch('trip/:id/passengers')
  async updatePassengers(
    @Param('id') id: string,
    @Body() dto: UpdatePassengersDto,
  ) {
    return this.ctDriverService.updatePassengers(
      parseInt(id),
      dto.passengerCount
    );
  }
}
```

Лістинг 8.3 – Контролер CtDriverController

**Автентифікація** реалізована через JWT та Redis (лістинг 8.4):

```typescript
@Injectable()
export class AuthService {
  constructor(
    private readonly jwtService: JwtService,
    private readonly sessionService: SessionService,
    private readonly config: ConfigService,
  ) {}

  async login(login: string, password: string) {
    // Спроба підключення до БД для перевірки credentials
    const pool = new Pool({
      host: this.config.get('DB_HOST'),
      database: this.config.get('DB_NAME'),
      user: login,
      password: password,
    });

    try {
      const client = await pool.connect();

      // Отримання ролей користувача
      const rolesResult = await client.query(`
        SELECT p.rolname FROM pg_auth_members am
        JOIN pg_roles pr ON am.member = pr.oid
        JOIN pg_roles p ON am.roleid = p.oid
        WHERE pr.rolname = $1 AND p.rolname LIKE 'ct_%_role'
      `, [login]);

      const roles = rolesResult.rows.map(r => r.rolname);
      client.release();
      await pool.end();

      // Генерація JWT та збереження сесії в Redis
      const token = this.jwtService.sign({ login });
      await this.sessionService.create(token, { login, password, roles });

      return { token, roles };
    } catch (error) {
      throw new UnauthorizedException('Invalid credentials');
    }
  }
}
```

Лістинг 8.4 – Сервіс AuthService

## 8.2 **Реалізація фронтенд-додатку** {#реалізація-фронтенд-додатку}

Фронтенд побудовано на React 19 з TanStack Router та TanStack Query.

**Налаштування маршрутизації** (лістинг 8.5):

```typescript
// src/routes/__root.tsx
export const Route = createRootRoute({
  component: () => (
    <ThemeProvider>
      <Header />
      <main>
        <Outlet />
      </main>
      <Toaster />
    </ThemeProvider>
  ),
});

// src/routes/driver/index.tsx
export const Route = createFileRoute('/driver/')({
  beforeLoad: ({ context }) => {
    if (!context.auth.roles.includes('ct_driver_role')) {
      throw redirect({ to: '/login' });
    }
  },
  component: DriverDashboard,
});
```

Лістинг 8.5 – Налаштування маршрутизації

**Компонент карти маршрутів** (лістинг 8.6):

```typescript
// src/components/RouteMap.tsx
export function RouteMap({ routeId }: { routeId: number }) {
  const mapContainer = useRef<HTMLDivElement>(null);
  const map = useRef<maplibregl.Map | null>(null);

  const { data: points } = useQuery({
    queryKey: ['route-points', routeId],
    queryFn: () => guestApi.getRoutePoints(routeId),
  });

  const { data: stops } = useQuery({
    queryKey: ['route-stops', routeId],
    queryFn: () => guestApi.getRouteStops(routeId),
  });

  useEffect(() => {
    if (!mapContainer.current || map.current) return;

    map.current = new maplibregl.Map({
      container: mapContainer.current,
      style: 'https://tiles.openfreemap.org/styles/liberty',
      center: [30.5234, 50.4501], // Київ
      zoom: 12,
    });

    return () => map.current?.remove();
  }, []);

  useEffect(() => {
    if (!map.current || !points?.length) return;

    const coordinates = points.map(p => [p.lon, p.lat]);

    map.current.addSource('route', {
      type: 'geojson',
      data: {
        type: 'Feature',
        geometry: { type: 'LineString', coordinates },
      },
    });

    map.current.addLayer({
      id: 'route-line',
      type: 'line',
      source: 'route',
      paint: { 'line-color': '#3b82f6', 'line-width': 4 },
    });
  }, [points]);

  return <div ref={mapContainer} className="w-full h-96 rounded-lg" />;
}
```

Лістинг 8.6 – Компонент карти маршрутів

**Zustand store для автентифікації** (лістинг 8.7):

```typescript
// src/stores/auth-store.ts
interface AuthState {
  token: string | null;
  roles: string[];
  login: (credentials: LoginDto) => Promise<void>;
  logout: () => void;
}

export const useAuthStore = create<AuthState>()(
  persist(
    (set) => ({
      token: null,
      roles: [],

      login: async (credentials) => {
        const response = await authApi.login(credentials);
        set({ token: response.token, roles: response.roles });
      },

      logout: () => {
        set({ token: null, roles: [] });
      },
    }),
    { name: 'auth-storage' }
  )
);
```

Лістинг 8.7 – Zustand store для автентифікації

# 9 **БЕЗПЕКА ІНФОРМАЦІЙНОЇ СИСТЕМИ** {#безпека-інформаційної-системи}

Безпека системи забезпечується на кількох рівнях:

**1. Рівень бази даних:**
- Окремі PostgreSQL-ролі для кожного типу користувача;
- SECURITY DEFINER функції з обмеженим search_path;
- Представлення з SECURITY BARRIER для фільтрації даних;
- CHECK-обмеження для валідації даних;
- session_user для аудиту операцій.

**2. Рівень бекенду:**
- JWT-автентифікація з зберіганням сесій у Redis;
- RolesGuard для перевірки ролей на кожному ендпоінті;
- Валідація вхідних даних через class-validator;
- PostgresExceptionFilter для коректної обробки помилок БД.

**3. Рівень фронтенду:**
- Зберігання токена в localStorage;
- Автоматичне додавання Bearer-токена до запитів;
- Редирект на сторінку входу при відсутності прав.

**Приклад перевірки прав** (лістинг 9.1):

```typescript
// RolesGuard
@Injectable()
export class RolesGuard implements CanActivate {
  constructor(private reflector: Reflector) {}

  canActivate(context: ExecutionContext): boolean {
    const requiredRoles = this.reflector.getAllAndOverride<string[]>('roles', [
      context.getHandler(),
      context.getClass(),
    ]);

    if (!requiredRoles) return true;

    const request = context.switchToHttp().getRequest();
    const userRoles = request.user?.roles || [];

    return requiredRoles.some((role) => userRoles.includes(role));
  }
}
```

Лістинг 9.1 – Guard для перевірки ролей

**Приклад SECURITY DEFINER функції** з перевіркою власника (лістинг 9.2):

```sql
CREATE FUNCTION passenger_api.buy_ticket(p_card_id BIGINT, p_trip_id BIGINT, p_price NUMERIC)
RETURNS BIGINT
LANGUAGE plpgsql SECURITY DEFINER
SET search_path TO 'public', 'pg_catalog'
AS $$
DECLARE v_bal NUMERIC; v_tid BIGINT; v_uid BIGINT;
BEGIN
    -- Перевірка власника картки
    SELECT user_id, balance INTO v_uid, v_bal
    FROM transport_cards WHERE id = p_card_id FOR UPDATE;

    IF (SELECT id FROM users WHERE login = session_user) != v_uid THEN
        RAISE EXCEPTION 'Not your card';
    END IF;

    IF v_bal < p_price THEN
        RAISE EXCEPTION 'Insufficient balance';
    END IF;

    -- Атомарна операція
    UPDATE transport_cards SET balance = balance - p_price WHERE id = p_card_id;

    INSERT INTO tickets (trip_id, card_id, price)
    VALUES (p_trip_id, p_card_id, p_price)
    RETURNING id INTO v_tid;

    RETURN v_tid;
END;
$$;
```

Лістинг 9.2 – SECURITY DEFINER функція з перевіркою прав

# 10 **ІНСТРУКЦІЯ КОРИСТУВАЧА** {#інструкція-користувача}

Інформаційна система реалізована як веб-застосунок. Для роботи з системою потрібен сучасний веб-браузер.

## 10.1 **Загальні сторінки** {#загальні-сторінки}

**Головна сторінка** відображає форму пошуку маршрутів та карту міста.

**[ВСТАВИТИ СКРІНШОТ: головна сторінка з формою пошуку маршрутів та картою]**

Рисунок 10.1 – Головна сторінка системи

Користувач може ввести початкову та кінцеву точки для пошуку оптимального маршруту, або переглянути список найближчих зупинок за GPS-координатами.

**Сторінка входу** дозволяє автентифікуватися з логіном та паролем.

**[ВСТАВИТИ СКРІНШОТ: форма входу]**

Рисунок 10.2 – Форма входу в систему

**Сторінка реєстрації** доступна лише для пасажирів.

**[ВСТАВИТИ СКРІНШОТ: форма реєстрації]**

Рисунок 10.3 – Форма реєстрації пасажира

## 10.2 **Сторінки пасажира** {#сторінки-пасажира}

**Особистий кабінет** містить інформацію про транспортні картки та баланс.

**[ВСТАВИТИ СКРІНШОТ: кабінет пасажира з картками]**

Рисунок 10.4 – Особистий кабінет пасажира

**Історія поїздок** відображає всі придбані квитки.

**[ВСТАВИТИ СКРІНШОТ: історія поїздок]**

Рисунок 10.5 – Історія поїздок

**Штрафи** показує список штрафів та дозволяє їх оскаржити.

**[ВСТАВИТИ СКРІНШОТ: список штрафів з кнопкою оскарження]**

Рисунок 10.6 – Перегляд та оскарження штрафів

## 10.3 **Сторінки водія** {#сторінки-водія}

**Робочий графік** показує призначені рейси на день.

**[ВСТАВИТИ СКРІНШОТ: графік водія]**

Рисунок 10.7 – Робочий графік водія

**Управління рейсом** дозволяє розпочати та завершити рейс.

**[ВСТАВИТИ СКРІНШОТ: кнопки старт/завершення рейсу]**

Рисунок 10.8 – Управління рейсом

## 10.4 **Сторінки диспетчера** {#сторінки-диспетчера}

**Дашборд** відображає статистику: активні рейси, відхилення, непризначені водії.

**[ВСТАВИТИ СКРІНШОТ: дашборд диспетчера]**

Рисунок 10.9 – Панель диспетчера

**Управління розкладами** дозволяє створювати та редагувати розклади.

**[ВСТАВИТИ СКРІНШОТ: форма створення розкладу]**

Рисунок 10.10 – Створення розкладу

**Призначення водіїв** на транспортні засоби.

**[ВСТАВИТИ СКРІНШОТ: форма призначення водія]**

Рисунок 10.11 – Призначення водія на транспорт

## 10.5 **Сторінки контролера** {#сторінки-контролера}

**Перевірка картки** дозволяє ввести номер картки та перевірити останню поїздку.

**[ВСТАВИТИ СКРІНШОТ: форма перевірки картки]**

Рисунок 10.12 – Перевірка транспортної картки

**Виписування штрафу** з вибором рейсу та введенням причини.

**[ВСТАВИТИ СКРІНШОТ: форма штрафу]**

Рисунок 10.13 – Виписування штрафу

## 10.6 **Сторінки менеджера** {#сторінки-менеджера}

**Управління водіями** — найм та перегляд списку водіїв.

**[ВСТАВИТИ СКРІНШОТ: форма найму водія]**

Рисунок 10.14 – Найм водія

**Управління транспортом** — додавання нових одиниць техніки.

**[ВСТАВИТИ СКРІНШОТ: форма додавання транспорту]**

Рисунок 10.15 – Додавання транспорту

## 10.7 **Сторінки бухгалтера** {#сторінки-бухгалтера}

**Фінансові звіти** з вибором періоду та відображенням доходів/витрат.

**[ВСТАВИТИ СКРІНШОТ: фінансовий звіт]**

Рисунок 10.16 – Фінансовий звіт

**Нарахування зарплат** водіям.

**[ВСТАВИТИ СКРІНШОТ: форма нарахування зарплати]**

Рисунок 10.17 – Нарахування зарплати

## 10.8 **Сторінки департаменту мерії** {#сторінки-департаменту-мерії}

**Створення маршрутів** з інтерактивною картою.

**[ВСТАВИТИ СКРІНШОТ: редактор маршруту на карті]**

Рисунок 10.18 – Створення маршруту

**Аналітика пасажиропотоку** з графіками та фільтрами.

**[ВСТАВИТИ СКРІНШОТ: графіки пасажиропотоку]**

Рисунок 10.19 – Аналітика пасажиропотоку

**Перегляд скарг** та зміна їх статусу.

**[ВСТАВИТИ СКРІНШОТ: список скарг]**

Рисунок 10.20 – Перегляд скарг та пропозицій

# **ВИСНОВКИ** {#висновки}

У результаті виконання курсового проєкту було спроєктовано та реалізовано інформаційну систему «Міський транспорт» для автоматизації процесів управління міським громадським транспортом.

Під час розробки вирішено такі завдання:

1. **Проведено системний аналіз предметної області.** Визначено 8 типів користувачів системи (гість, пасажир, водій, диспетчер, контролер, менеджер, бухгалтер, департамент мерії) та понад 40 функціональних задач для них.

2. **Побудовано інфологічну та даталогічну моделі бази даних.** Спроєктовано 23 таблиці, що охоплюють усі аспекти предметної області: маршрути, зупинки, транспортні засоби, водіїв, розклади, рейси, транспортні картки, квитки, штрафи та фінансові операції.

3. **Реалізовано фізичну структуру бази даних.** Використано СУБД PostgreSQL 16 з розширеннями PostGIS для геопросторових операцій та pgRouting для маршрутизації. Впроваджено концепцію «товстої бази даних» з бізнес-логікою у вигляді SECURITY DEFINER функцій.

4. **Налаштовано підсистему безпеки.** Створено 8 PostgreSQL-ролей та відповідних схем API для розмежування доступу. Кожен користувач системи працює під власною PostgreSQL-роллю, що забезпечує захист даних на рівні СУБД.

5. **Розроблено серверну частину.** Створено бекенд на NestJS 11 з модульною архітектурою, JWT-автентифікацією та динамічним управлінням пулами з'єднань до БД для кожного користувача.

6. **Розроблено клієнтський інтерфейс.** Реалізовано SPA на React 19 з TanStack Router, TanStack Query, Zustand та MapLibre GL для візуалізації маршрутів на карті.

Система відповідає поставленим вимогам та забезпечує:
- централізоване управління маршрутами, розкладами та транспортними засобами;
- автоматизацію продажу квитків та обліку пасажиропотоку;
- контроль штрафів з можливістю оскарження;
- формування фінансової звітності;
- розмежування доступу на рівні бази даних.

Перспективами подальшого розвитку системи є:
- інтеграція з GPS-трекерами транспорту в реальному часі;
- розробка мобільного додатку;
- впровадження системи прогнозування пасажиропотоку на основі історичних даних;
- інтеграція з банківськими API для онлайн-оплати.

# **СПИСОК ВИКОРИСТАНИХ ДЖЕРЕЛ** {#список-використаних-джерел}

1. PostgreSQL 16 Documentation. — URL: https://www.postgresql.org/docs/16/

2. PostGIS Documentation. — URL: https://postgis.net/documentation/

3. NestJS Documentation. — URL: https://docs.nestjs.com/

4. React Documentation. — URL: https://react.dev/

5. TanStack Router Documentation. — URL: https://tanstack.com/router/latest

6. TanStack Query Documentation. — URL: https://tanstack.com/query/latest

7. Drizzle ORM Documentation. — URL: https://orm.drizzle.team/docs/overview

8. MapLibre GL JS Documentation. — URL: https://maplibre.org/maplibre-gl-js/docs/

9. Zustand Documentation. — URL: https://docs.pmnd.rs/zustand

10. Дейт К. Дж. Введение в системы баз данных / К. Дж. Дейт — 8-е изд. — М.: Вильямс, 2005. — 1328 с.

11. Коннолли Т. Базы данных. Проектирование, реализация и сопровождение / Т. Коннолли, К. Бегг — 3-е изд. — М.: Вильямс, 2003. — 1440 с.

# **ДОДАТОК А СХЕМА БАЗИ ДАНИХ** {#додаток-а-схема-бази-даних}

**[ВСТАВИТИ ДІАГРАМУ: повна ER-діаграма бази даних з усіма 23 таблицями, їх атрибутами та зв'язками. Можна згенерувати в pgAdmin або Valentina Studio]**

Рисунок А.1 – Схема бази даних інформаційної системи «Міський транспорт»

# **ДОДАТОК Б SQL-ЗАПИТИ ДЛЯ СТВОРЕННЯ ТАБЛИЦЬ, РОЛЕЙ ТА РОЗПОДІЛУ ДОСТУПУ** {#додаток-б-sql-запити}

**[ВСТАВИТИ: основні SQL-запити з файлу schema_dump.sql або з міграцій Drizzle — створення таблиць, індексів, обмежень та ролей. Можна взяти з /backend/drizzle/ та /db/bootstrap.sql]**

# **ДОДАТОК В ЗАПИТИ НА СТВОРЕННЯ ФУНКЦІЙ ТА ПРЕДСТАВЛЕНЬ** {#додаток-в-запити-на-створення-функцій}

**[ВСТАВИТИ: код основних SECURITY DEFINER функцій та представлень з кожної схеми API. Можна взяти з schema_dump.sql — функції guest_api.*, passenger_api.*, driver_api.*, dispatcher_api.*, controller_api.*, manager_api.*, municipality_api.*, accountant_api.*]**

# **ДОДАТОК Г ВИХІДНИЙ КОД ОСНОВНИХ КЛАСІВ** {#додаток-г-вихідний-код}

**[ВСТАВИТИ: код основних класів бекенду (контролери, сервіси, guards) та фронтенду (компоненти, stores, API-клієнти). Файли можна взяти з /backend/src/roles/ та /frontend/src/]**

# **ДОДАТОК Д ІЄРАРХІЯ СТОРІНОК ДОДАТКУ** {#додаток-д-ієрархія-сторінок}

**[ВСТАВИТИ ДІАГРАМУ: повна ієрархія веб-сторінок для всіх ролей користувачів — головна, login, register, та гілки passenger/, driver/, dispatcher/, controller/, manager/, municipality/, accountant/ з усіма підсторінками]**

Рисунок Д.1 – Ієрархія сторінок додатку для користувачів системи
