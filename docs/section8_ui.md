# 8 ПРОГРАМНА РЕАЛІЗАЦІЯ ІНТЕРФЕЙСУ

Програмна реалізація системи виконана як веб-застосунок. Серверна частина обробляє HTTP-запити і взаємодіє з базою даних, а клієнтська частина відображає дані користувачу та забезпечує сценарії роботи. Архітектура підтримує рольовий доступ - кожен користувач працює у власному кабінеті з відповідним набором функцій.

Клієнт побудовано на React і Vite, маршрутизація виконується через TanStack Router, а отримання даних - через React Query. Серверна частина реалізована на NestJS і надає рольові ендпоінти для гостя, пасажира, водія, диспетчера, контролера, менеджера, представника мерії та бухгалтера.

## 8.1 Програмна реалізація серверної частини

Сервер організовано у вигляді модулів і контролерів, які відповідають конкретним ролям та сценаріям. Базові дії автентифікації винесені в `auth`-контролер, а спеціалізовані операції - у рольові контролери (guest, passenger, driver, dispatcher, controller, manager, municipality, accountant). Нижче наведено спрощений фрагмент обробки авторизаційних запитів.

```ts
@Controller('auth')
export class AuthController {
  @Post('register')
  register(payload: RegisterDto) {
    return authService.register(payload)
  }

  @Post('login')
  login(payload: LoginDto) {
    return authService.login(payload)
  }

  @Post('logout')
  logout(authorization?: string) {
    const token = extractBearerToken(authorization)
    return authService.logout(token)
  }
}
```

Лістинг 8.1 - Обробка реєстрації, входу і виходу

Контролер приймає запити на реєстрацію і автентифікацію та делегує їх сервісу. Метод `login` формує відповідь з токеном, який клієнт використовує для доступу до рольових ендпоінтів. Метод `logout` зчитує токен з заголовка Authorization і завершує сесію. Такий підхід дозволяє централізовано керувати доступом до функцій інтерфейсу.

Приклад рольового контролера показує, як водій працює з рейсами і GPS-даними через окремі HTTP-ендпоінти.

```ts
@Controller('driver')
export class CtDriverController {
  @Get('schedule')
  getSchedule(date?: string) {
    return driverService.getScheduleByLogin(date)
  }

  @Post('trips/start')
  startTrip(payload: StartTripDto) {
    return driverService.startTrip(payload)
  }

  @Post('trips/finish')
  finishTrip(payload: FinishTripDto) {
    return driverService.finishTrip(payload)
  }

  @Post('trips/gps')
  logGps(payload: GpsLogDto) {
    return driverService.logGps(payload)
  }
}
```

Лістинг 8.2 - Рольовий контролер водія

Запити `trips/start` і `trips/finish` змінюють стан рейсу і фіксують фактичний час початку та завершення. Виклик `trips/gps` передає координати транспорту, що використовуються для диспетчерського моніторингу. Ендпоінт `schedule` повертає актуальний розклад водія і пов’язаний маршрут. Розділення ендпоінтів за ролями спрощує клієнтську інтеграцію і відповідає логіці предметної області.

## 8.2 Програмна реалізація клієнтської частини

Клієнтська частина реалізована як односторінковий веб-інтерфейс. Навігація організована через маршрути і загальне меню, а дані завантажуються асинхронно через React Query. Для картографічних сценаріїв використано MapLibre, а для аналітики - графіки на основі Recharts. Інтерфейс відображає окремі кабінети для кожної ролі:

- гість - карта маршрутів, розклад, пошук зупинок, подання звернень
- пасажир - профіль, транспортна картка, поїздки, штрафи, апеляції
- водій - розклад, активний рейс, передавання пасажиропотоку і GPS
- диспетчер - управління розкладом, призначеннями та моніторингом
- контролер - перевірка карток і виписування штрафів
- менеджер - управління персоналом і транспортом
- представник мерії - маршрути, зупинки та аналітика пасажиропотоку
- бухгалтер - бюджети, доходи, витрати і зарплати

Приклад клієнтської логіки перенаправлення після входу наведено нижче.

```ts
const ROLE_ROUTES = [
  { role: 'ct_manager_role', path: '/manager' },
  { role: 'ct_dispatcher_role', path: '/dispatcher' },
  { role: 'ct_municipality_role', path: '/municipality' },
  { role: 'ct_accountant_role', path: '/accountant' },
  { role: 'ct_controller_role', path: '/controller' },
  { role: 'ct_driver_role', path: '/driver' },
  { role: 'ct_passenger_role', path: '/passenger' },
]

const target = ROLE_ROUTES.find((item) => data.roles.includes(item.role))
setTimeout(() => navigate(target?.path ?? '/'), 500)
```

Лістинг 8.3 - Рольове перенаправлення користувача

Перенаправлення відповідає ролі, яку сервер повертає під час входу. Список ролей з відповіді зберігається разом із токеном, після чого інтерфейс обирає перший відповідний маршрут із таблиці ROLE_ROUTES. Затримка використовується для короткого підтвердження успішного входу. Якщо роль не визначено, система повертає на головну сторінку.

Для отримання даних інтерфейс використовує запити до рольових API-модулів. Приклад завантаження історії поїздок пасажира показано нижче.

```ts
const { data: trips } = useQuery({
  queryKey: ['passenger-trips'],
  queryFn: getMyTrips,
})
```

Лістинг 8.4 - Завантаження даних через React Query

Запит ініціюється при відкритті кабінету пасажира та повертає список поїздок. Отримані дані використовуються для побудови таблиць і карток, а стан завантаження дозволяє показати користувачу індикатори. Аналогічно організовані запити для диспетчера, мерії та бухгалтера.

У підсумку інтерфейс забезпечує повний набір сценаріїв для всіх ролей системи. Клієнтська частина надає єдиний стиль взаємодії і зрозумілу навігацію. Серверні ендпоінти групуються за ролями і відображають бізнес-операції предметної області. Розподіл на ролі спрощує контроль доступу та робить інтерфейс безпечним. Візуальні інструменти карт і графіків підтримують аналітичні сценарії. Таким чином реалізація інтерфейсу відповідає вимогам системи міського транспорту і готова до подальшого розширення.
